<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Roadmap Agent</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        /* .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        } */
        /* è®©ä¸»å®¹å™¨æ›´å®½ï¼šç”¨è§†å£å®½åº¦è€Œä¸æ˜¯å›ºå®š 1400px */
        .container {
        width: min(95vw, 1800px);   /* åŸºæœ¬é“ºæ»¡å±å¹•ï¼Œæœ€å¤šåˆ° 1800px */
        margin: 16px auto;          /* ä»ç„¶å±…ä¸­ï¼Œç•™ä¸€ç‚¹ä¸Šä¸‹å¤–è¾¹è· */
        background: white;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        overflow: hidden;
        padding: 0 16px;            /* ç»™å†…ä¾§ç•™ç‚¹å‘¼å¸ç©ºé—´ */
        }

        /* å·¦å³å¸ƒå±€ */
        .main {
        display: flex;
        gap: 16px;                  /* å·¦å³ç•™ç¼éš™ */
        align-items: stretch;
        }

        /* å·¦è¾¹ï¼šçŸ¥è¯†å›¾è°±ï¼ˆæ›´å¤§ï¼‰ */
        .left-panel {
        flex: 3 1 0;                /* æ¯”ä¾‹ 3 */
        min-width: 0;               /* é˜²æ­¢ flex å­é¡¹æ’‘çˆ†æ¢è¡Œ */
        }

        /* å³è¾¹ï¼šdashboardï¼ˆæ›´å°ï¼‰ */
        .right-panel {
        flex: 1 1 320px;            /* æ¯”ä¾‹ 1ï¼Œå¹¶ç»™ä¸ªåˆç†çš„æœ€å°åŸºçº¿ */
        max-width: 520px;           /* é˜²æ­¢è¿‡å®½ */
        }

        /* å°å±æ”¹ä¸ºä¸Šä¸‹å †å  */
        @media (max-width: 992px) {
        .container { width: 98vw; }
        .main { flex-direction: column; }
        .right-panel { max-width: none; }
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .input-section {
            padding: 20px;
            background: #ecf0f1;
            border-bottom: 2px solid #bdc3c7;
        }

        .input-group {
            display: flex;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }

        #topicInput {
            flex: 1;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            outline: none;
        }

        #topicInput:focus {
            border-color: #3498db;
        }

        #generateBtn {
            padding: 12px 24px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #generateBtn:hover {
            background: #2980b9;
        }

        #generateBtn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            min-height: 800px;
        }

        .graph-container {
            flex: 2;
            position: relative;
            border-right: 2px solid #ecf0f1;
        }

        .sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
        }

        .dashboard {
            background: #0B2d78;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .dashboard h3 {
            margin-bottom: 10px;
        }

        .progress {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .panel {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            border-bottom: 1px solid #dee2e6;
        }

        .panel h3 {
            display: block;
            width: 100%;            /* æ’‘æ»¡ */
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 12px;
            border-left: 4px solid #3498db;
            background: #ecf0f1;
        }

        .log-entry.search {
            border-left-color: #4169e1;
            background: #63d1d0;
        }

        .log-entry.llm {
            border-left-color: #4169e1;
            background: #adeff2;
        }

        .log-entry.output {
            border-left-color: #4169e1;
            background: #dcfdfa;
        }

        .log-entry.error {
            border-left-color: #e74c3c;
            background: #fdf2f2;
        }

        .source-item {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
            border: 1px solid #e9ecef;
            box-sizing: border-box;
        }

        .source-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .source-snippet {
            font-size: 14px;
            color: #7f8c8d;
            margin: 5px 0;
        }

        .source-url {
            font-size: 14px;
            color: #3498db;
            text-decoration: none;
        }

        .source-url:hover {
            text-decoration: underline;
        }

        #graph-svg {
            width: 100%;
            height: 100%;
            background: #fafafa;
        }

        .node {
            cursor: pointer;
            stroke-width: 2.5;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .node.unlearned {
            fill: #95a5a6;
            stroke: #7f8c8d;
        }

        .node.lit {
            fill: #a3f2ea;
            stroke: #a3f2ea;
        }

        .node.recommended {
            fill: #95a5a6;
            stroke: #FF6100;
            stroke-width: 4;
        }

        .node-label {
            font-size: 10px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
        }

        .label-container {
            pointer-events: none;
        }

        .node-label-line {
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            user-select: none;
            pointer-events: none;
        }

        .link {
            stroke: #bdc3c7;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(0,0,0,0.9);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 18px;
            color: #7f8c8d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .source-item.source-highlight {
            border-left: 6px solid #FF6100 !important;
            box-shadow: 0 0 10px #FF6100;
            background: #fffbe6;
            transition: box-shadow 0.2s, background 0.2s, border-color 0.2s;
        }
        .sidebar {
        flex: 1 1 320px;     /* æ¯”ä¾‹ä»ç„¶å³å°äºå·¦ */
        max-width: 520px;    /* å³ä¾§æœ€å¤§å®½åº¦ï¼Œé˜²æ­¢è¿‡å®½ */
        min-width: 320px;    /* ç»™ä¸ªä¸‹é™ï¼Œé¿å…å¤ªçª„ */
        display: flex;
        flex-direction: column;
        min-height: 0;       /* é…åˆ flex å®¹å™¨ï¼Œé¿å…æº¢å‡º */
        }

        /* å·¦ä¾§æ›´å¤§ä¸€äº›å¹¶å…è®¸ç¼©å° */
        .graph-container {
        flex: 3 1 0;
        min-width: 0;        /* é˜²æ­¢æŠŠå³ä¾§æŒ¤èµ° */
        }

        /* â€”â€” Logs ç´§å‡‘&è‡ªåŠ¨æ¢è¡Œ â€”â€” */
        #logs-container {
        width: 100%;
        }

        .log-entry {
        font-size: 12px;
        line-height: 1.35;
        padding: 8px 10px;
        margin: 6px 0;
        white-space: normal;        /* å…è®¸æ¢è¡Œ */
        overflow-wrap: anywhere;    /* è¶…é•¿è¿ç»­å•è¯ä¹Ÿæ–­è¡Œ */
        }

        .log-entry strong {
        display: block;             /* æ—¶é—´æˆ³/é˜¶æ®µå•ç‹¬ä¸€è¡Œæ›´æ¸…æ™° */
        margin-bottom: 4px;
        }

        /* å¯é€‰ï¼šæŠŠæ¯æ¡ log åšæˆâ€œå¡ç‰‡â€ç¼©è¿›ä¸€ç‚¹ï¼Œè§†è§‰æ›´ç´§å‡‘ */
        .panel #logs-container .log-entry {
        margin-left: 2px;
        margin-right: 2px;
        }

        /* â€”â€” çª„å±ï¼šä¸Šä¸‹å †å ï¼Œä¸é®æŒ¡ â€”â€” */
        @media (max-width: 992px) {
        .main-content {
            flex-direction: column; /* ä»å·¦å³æ”¹ä¸ºä¸Šä¸‹ */
            height: auto;           /* å–æ¶ˆå›ºå®š 800pxï¼Œé¿å…é®æŒ¡ */
        }
        .graph-container,
        .sidebar {
            flex: none;
            width: 100%;
            max-width: none;        /* å³ä¾§æ’‘æ»¡å±å®½ */
        }
        #graph-svg {
            height: 60vh;           /* ç»™å›¾ä¸€ä¸ªç›¸å¯¹é«˜åº¦ï¼Œé¿å…å¤ªçŸ®æˆ–å¤ªé«˜ */
        }
        }
        #logs-container {
        display: flex;
        flex-direction: column;
        gap: 4px;                 /* æ¡ç›®ä¹‹é—´æ›´è¿‘ */
        }

        .log-entry {
        display: flex;            /* å¼ºè°ƒå‰ç¼€ + æ–‡æœ¬åŒä¸€è¡Œ */
        align-items: flex-start;
        gap: 6px;                 /* å‰ç¼€ä¸æ­£æ–‡çš„é—´è· */
        font-size: 11.5px;        /* æ›´å°æ›´ç´§å‡‘ */
        line-height: 1.2;
        padding: 6px 8px;         /* æ›´å°å†…è¾¹è· */
        margin: 0;                /* ç”± gap æ§åˆ¶é—´è· */
        white-space: normal;
        word-break: break-word;
        overflow-wrap: anywhere;
        border-radius: 4px;
        border-left-width: 3px;   /* å·¦è¾¹å½©æ¡æ›´ç»† */
        }

        /* å‰ç¼€ä¿æŒä¸€è¡Œä¸æŠ˜ */
        .log-entry strong {
        display: inline;          /* å–æ¶ˆå—çº§å¯¼è‡´çš„æ¢è¡Œ */
        white-space: nowrap;      /* æ—¶é—´æˆ³+é˜¶æ®µä¸æ¢è¡Œ */
        margin: 0;
        }
        .panel {
        flex: unset;         /* ä¸è¦ flex:1 */
        height: auto;        /* é«˜åº¦ç”±å†…å®¹å†³å®š */
        max-height: 300px;   /* å¯é€‰ï¼šé™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé¿å…å¤ªé•¿ */
        overflow-y: auto;    /* å†…å®¹å¤ªå¤šæ—¶æ‰æ»šåŠ¨ */
        padding-bottom: 20px; /* ç¡®ä¿åº•éƒ¨æœ‰è¶³å¤Ÿç©ºé—´ */
        }
        #graph-svg {
        width: 100%;
        height: 100%;
        border-radius: 16px; /* åœ†è§’æ›´æŸ”å’Œ */
        background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05)) padding-box,
                    radial-gradient(circle at 20% 30%, rgba(73, 130, 255, 0.25), transparent 50%),
                    radial-gradient(circle at 80% 70%, rgba(150, 69, 227, 0.25), transparent 50%),
                    #e4eee6; 
        backdrop-filter: blur(20px);  /* ç£¨ç ‚å…³é”® */
        -webkit-backdrop-filter: blur(20px);
        box-shadow: inset 0 0 40px rgba(255,255,255,0.05);
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Roadmap Agent</h1>
            <p>Generate AI-powered learning roadmaps for any topic</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <input type="text" id="topicInput" placeholder="Enter a learning topic (e.g., 'Python basics', 'machine learning')" value="Python basics">
                <button id="generateBtn">Generate Roadmap</button>
            </div>
        </div>

        <div class="main-content">
            <div class="graph-container">
                <div id="graph-loading" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Generating your roadmap...</span>
                </div>
                <svg id="graph-svg"></svg>
            </div>

            <div class="sidebar">
                <div class="dashboard">
                    <h3>Progress Dashboard</h3>
                    <span class="progress" id="progress-percentage">0%</span>
                    &nbsp;&nbsp;
                    <span id="progress-details">0 / 0 completed</span>

                </div>

                <div class="panel">
                    <h3>ğŸ“‹ Agent Logs</h3>
                    <div id="logs-container">
                        <p style="color: #7f8c8d; text-align: center;">Generate a roadmap to see agent steps...</p>
                    </div>
                </div>

                <div class="panel">
                    <h3>ğŸ” Sources</h3>
                    <div id="sources-container">
                        <p style="color: #7f8c8d; text-align: center;">Sources will appear here...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class RoadmapAgent {
            constructor() {
                this.svg = d3.select("#graph-svg");
                this.updateDimensions();
                this.nodes = [];
                this.links = [];
                this.simulation = null;
                this.tooltip = null;

                this.setupSVG();
                this.setupEventListeners();
                this.createTooltip();

                // Update dimensions on window resize
                window.addEventListener('resize', () => {
                    this.updateDimensions();
                });
            }

            updateDimensions() {
                const container = document.querySelector('.graph-container');
                this.width = container.clientWidth || 800;
                this.height = container.clientHeight || 600;
                this.svg.attr("width", this.width).attr("height", this.height);
            }

            // æ–°å¢ï¼šé«˜äº®Sourceå¡ç‰‡
            highlightSourceCard(url) {
                const cards = document.querySelectorAll('.source-item');
                cards.forEach(card => {
                    const link = card.querySelector('.source-url');
                    if (link && link.href === url) {
                        card.classList.add('source-highlight');
                    }
                });
            }

            // æ–°å¢ï¼šæ¸…é™¤é«˜äº®
            clearSourceHighlight() {
                document.querySelectorAll('.source-item.source-highlight').forEach(card => {
                    card.classList.remove('source-highlight');
                });
            }

            setupSVG() {
                // Define arrow marker
                this.svg.append("defs").selectAll("marker")
                    .data(["arrowhead"])
                    .enter().append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 20)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "#bdc3c7");
            }

            setupEventListeners() {
                const generateBtn = document.getElementById('generateBtn');
                const topicInput = document.getElementById('topicInput');

                generateBtn.addEventListener('click', () => this.generateRoadmap());
                topicInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.generateRoadmap();
                    }
                });
            }

            createTooltip() {
                this.tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0);
            }

            async generateRoadmap() {
                const topic = document.getElementById('topicInput').value.trim();
                if (!topic) return;

                const generateBtn = document.getElementById('generateBtn');
                const loadingDiv = document.getElementById('graph-loading');

                // Show loading state
                generateBtn.disabled = true;
                generateBtn.textContent = 'Generating...';
                loadingDiv.style.display = 'flex';
                this.clearAll();

                try {
                    const response = await fetch(`/agent/roadmap?topic=${encodeURIComponent(topic)}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.detail || 'Failed to generate roadmap');
                    }

                    this.displayRoadmap(data);
                    this.displayLogs(data.logs);
                    this.displaySources(data.sources);

                } catch (error) {
                    console.error('Error:', error);
                    this.displayError(error.message);
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Roadmap';
                    loadingDiv.style.display = 'none';
                }
            }

            displayRoadmap(data) {
                this.nodes = data.nodes.map((node, i) => {
                    // Better initial positioning - spread nodes in a larger circle
                    const angle = (i / data.nodes.length) * 2 * Math.PI;
                    const radius = Math.min(this.width, this.height) * 0.35;
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;

                    return {
                        ...node,
                        x: centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 150,
                        y: centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 150,
                        status: Math.random() > 0.7 ? 'lit' : 'unlearned',
                        level: 0 // Will be calculated below
                    };
                });

                this.links = data.edges.map(edge => ({
                    source: edge.source,
                    target: edge.target,
                    relation: edge.relation
                }));

                // Calculate hierarchical levels for better vertical layout
                this.assignNodeLevels();

                // Mark some nodes as recommended (prerequisites of lit nodes)
                this.markRecommendedNodes();

                this.renderGraph();
                this.updateDashboard();
            }

            assignNodeLevels() {
                // Topological sort to assign levels (prerequisite depth)
                const nodeMap = new Map(this.nodes.map(node => [node.id, node]));
                const inDegree = new Map(this.nodes.map(node => [node.id, 0]));
                
                // Count incoming edges (prerequisites)
                this.links.forEach(link => {
                    inDegree.set(link.target, (inDegree.get(link.target) || 0) + 1);
                });
                
                // Start with nodes that have no prerequisites
                const queue = this.nodes.filter(node => inDegree.get(node.id) === 0);
                queue.forEach(node => node.level = 0);
                
                // Process nodes level by level
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    // Find all nodes that this node points to
                    this.links.forEach(link => {
                        if (link.source === current.id) {
                            const targetNode = nodeMap.get(link.target);
                            const newInDegree = inDegree.get(link.target) - 1;
                            inDegree.set(link.target, newInDegree);
                            
                            // Set level to be at least current level + 1
                            targetNode.level = Math.max(targetNode.level || 0, current.level + 1);
                            
                            if (newInDegree === 0) {
                                queue.push(targetNode);
                            }
                        }
                    });
                }
            }

            createHierarchy() {
                // Group nodes by level for positioning
                const hierarchy = {};
                this.nodes.forEach(node => {
                    if (!hierarchy[node.level]) {
                        hierarchy[node.level] = [];
                    }
                    hierarchy[node.level].push(node.id);
                });
                return hierarchy;
            }

            markRecommendedNodes() {
                const litNodes = new Set(this.nodes.filter(n => n.status === 'lit').map(n => n.id));
                const unlearnedNodes = new Set(this.nodes.filter(n => n.status === 'unlearned').map(n => n.id));

                this.nodes.forEach(node => {
                    if (node.status === 'unlearned') {
                        // Check if any of its targets are lit
                        const hasLitTarget = this.links.some(link => 
                            link.source === node.id && litNodes.has(link.target)
                        );
                        
                        if (hasLitTarget) {
                            node.status = 'recommended';
                        }
                    }
                });
            }

            renderGraph() {
                // Clear previous graph
                this.svg.selectAll("*:not(defs)").remove();

                // Create zoom behavior with wheel support
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                // Apply zoom behavior to SVG
                this.svg.call(zoom);

                // Create container for zoomable content
                const g = this.svg.append("g");

                // Create hierarchical layout for better vertical structure
                const hierarchy = this.createHierarchy();

                // Create simulation with more spread out layout
                this.simulation = d3.forceSimulation(this.nodes)
                    .force("link", d3.forceLink(this.links)
                        .id(d => d.id)
                        .distance(d => d.target.level > d.source.level ? 150 : 100)
                        .strength(0.3))
                    .force("charge", d3.forceManyBody().strength(-500))
                    .force("center", d3.forceCenter(this.width / 2, this.height / 2))
                    .force("collision", d3.forceCollide().radius(45))
                    .force("x", d3.forceX(this.width / 2).strength(0.05))
                    .force("y", d3.forceY(this.height / 2).strength(0.05));

                // Create links (å¿…é¡»åŠ ä¸Š)
                const link = g.append("g")
                    .attr("stroke", "#aaa")
                    .selectAll("path")
                    .data(this.links)
                    .enter().append("path")
                    .attr("class", "link")
                    .attr("marker-end", "url(#arrowhead)");

                // Create nodes
                const node = g.append("g")
                    .selectAll("circle")
                    .data(this.nodes)
                    .enter().append("circle")
                    .attr("class", d => `node ${d.status}`)
                    .attr("r", 25)
                    .on("mouseover", (event, d) => {
                        this.showTooltip(event, d);
                        this.highlightSourceCard(d.source_url);
                    })
                    .on("mouseout", (event, d) => {
                        this.hideTooltip();
                        this.clearSourceHighlight();
                    })
                    .on("click", (event, d) => this.toggleNodeStatus(d))
                    .call(d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on("drag", (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on("end", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        }));

                // Create labels with automatic text wrapping using proper data binding
                const labelGroup = g.append("g").attr("class", "labels");

                // Smart text wrapping function
                const wrapText = (text, maxCharsPerLine = 18) => {
                    const words = text.split(/[\s\-()]+/);
                    const lines = [];
                    let currentLine = '';

                    words.forEach(word => {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        if (testLine.length <= maxCharsPerLine) {
                            currentLine = testLine;
                        } else {
                            if (currentLine) lines.push(currentLine);
                            currentLine = word;
                        }
                    });
                    if (currentLine) lines.push(currentLine);

                    // If we still have lines that are too long, break them
                    const finalLines = [];
                    lines.forEach(line => {
                        if (line.length <= maxCharsPerLine) {
                            finalLines.push(line);
                        } else {
                            // Break long words
                            for (let i = 0; i < line.length; i += maxCharsPerLine) {
                                finalLines.push(line.substring(i, i + maxCharsPerLine));
                            }
                        }
                    });

                    return finalLines.slice(0, 3); // Maximum 3 lines
                };

                // Add wrapped lines to each node data
                this.nodes.forEach(node => {
                    node.wrappedLines = wrapText(node.title);
                });

                const labelContainers = labelGroup.selectAll(".label-container")
                    .data(this.nodes)
                    .enter().append("g")
                    .attr("class", "label-container");

                // Add text lines for each node
                labelContainers.each(function(d) {
                    const container = d3.select(this);
                    d.wrappedLines.forEach((line, i) => {
                        container.append("text")
                            .attr("class", "node-label-line")
                            .attr("dy", `${i * 1.2}em`)
                            .style("font-size", "10px")
                            .style("font-weight", "600")
                            .style("text-anchor", "middle")
                            .style("fill", "#2c3e50")
                            .style("paint-order", "stroke")
                            .style("stroke", "white")
                            .style("stroke-width", "2px")
                            .style("stroke-linejoin", "round")
                            .style("dominant-baseline", "central")
                            .text(line);
                    });
                });

                // Add boundary constraint function
                const boundNodes = () => {
                    const radius = 25;
                    this.nodes.forEach(d => {
                        d.x = Math.max(radius, Math.min(this.width - radius, d.x));
                        d.y = Math.max(radius, Math.min(this.height - radius, d.y));
                    });
                };

                // Update positions on simulation tick
                this.simulation.on("tick", () => {
                    // Apply boundary constraints
                    boundNodes();

                    link.attr("d", d => {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    // Position label containers below nodes
                    labelContainers
                        .attr("transform", d => `translate(${d.x}, ${d.y + 50})`);
                });

                // Initial zoom to fit content
                setTimeout(() => {
                    const bounds = g.node().getBBox();
                    const parent = this.svg.node().getBoundingClientRect();
                    const fullWidth = parent.width;
                    const fullHeight = parent.height;
                    const width = bounds.width;
                    const height = bounds.height;
                    const midX = bounds.x + width / 2;
                    const midY = bounds.y + height / 2;

                    const scale = Math.min(fullWidth / width, fullHeight / height) * 0.8;
                    const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

                    this.svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                }, 100);
            }

            showTooltip(event, d) {
                this.tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                
                this.tooltip.html(`
                    <strong>${d.title}</strong><br/>
                    <em>Type:</em> ${d.kind}<br/>
                    <em>Status:</em> ${d.status}<br/><br/>
                    ${d.brief}
                `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            }

            hideTooltip() {
                this.tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }

            toggleNodeStatus(node) {
                if (node.status === 'unlearned') {
                    node.status = 'lit';
                } else if (node.status === 'lit') {
                    node.status = 'unlearned';
                }
                
                // Update recommended nodes
                this.markRecommendedNodes();
                
                // Update visual appearance
                this.svg.selectAll(".node")
                    .attr("class", d => `node ${d.status}`);
                
                this.updateDashboard();
            }

            updateDashboard() {
                const litCount = this.nodes.filter(n => n.status === 'lit').length;
                const totalCount = this.nodes.length;
                const percentage = totalCount > 0 ? Math.round((litCount / totalCount) * 100) : 0;

                document.getElementById('progress-percentage').textContent = `${percentage}%`;
                document.getElementById('progress-details').textContent = `${litCount} / ${totalCount} completed`;
            }

            displayLogs(logs) {
                const container = document.getElementById('logs-container');
                container.innerHTML = '';

                logs.forEach(log => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${log.stage}`;
                    
                    const timestamp = new Date(log.ts).toLocaleTimeString();
                    logEntry.innerHTML = `<strong>[${timestamp}] ${log.stage.toUpperCase()}:</strong> ${log.message}`;

                    
                    container.appendChild(logEntry);
                });
            }

            displaySources(sources) {
                const container = document.getElementById('sources-container');
                container.innerHTML = '';

                sources.forEach(source => {
                    const sourceItem = document.createElement('div');
                    sourceItem.className = 'source-item';
                    sourceItem.innerHTML = `
                        <div class="source-title">${source.title}</div>
                        <div class="source-snippet">${source.snippet}</div>
                        <a href="${source.url}" class="source-url" target="_blank">${source.url}</a>
                    `;
                    container.appendChild(sourceItem);
                });
            }

            displayError(message) {
                const container = document.getElementById('logs-container');
                container.innerHTML = `
                    <div class="log-entry error">
                        <strong>ERROR:</strong><br/>
                        ${message}
                    </div>
                `;
            }

            clearAll() {
                document.getElementById('logs-container').innerHTML = '<p style="color: #7f8c8d; text-align: center;">Generating roadmap...</p>';
                document.getElementById('sources-container').innerHTML = '<p style="color: #7f8c8d; text-align: center;">Loading sources...</p>';
                document.getElementById('progress-percentage').textContent = '0%';
                document.getElementById('progress-details').textContent = '0 / 0 completed';
                this.svg.selectAll("*:not(defs)").remove();
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new RoadmapAgent();
        });
    </script>
</body>
</html>