<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Roadmap Agent</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .input-section {
            padding: 20px;
            background: #ecf0f1;
            border-bottom: 2px solid #bdc3c7;
        }

        .input-group {
            display: flex;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }

        #topicInput {
            flex: 1;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            outline: none;
        }

        #topicInput:focus {
            border-color: #3498db;
        }

        #generateBtn {
            padding: 12px 24px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #generateBtn:hover {
            background: #2980b9;
        }

        #generateBtn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            height: 800px;
        }

        .graph-container {
            flex: 2;
            position: relative;
            border-right: 2px solid #ecf0f1;
        }

        .sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
        }

        .dashboard {
            background: #2ecc71;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .dashboard h3 {
            margin-bottom: 10px;
        }

        .progress {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .panel {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            border-bottom: 1px solid #dee2e6;
        }

        .panel h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #3498db;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 14px;
            border-left: 4px solid #3498db;
            background: #ecf0f1;
        }

        .log-entry.search {
            border-left-color: #f39c12;
            background: #fef9e7;
        }

        .log-entry.llm {
            border-left-color: #9b59b6;
            background: #f4ecf7;
        }

        .log-entry.output {
            border-left-color: #27ae60;
            background: #eafaf1;
        }

        .log-entry.error {
            border-left-color: #e74c3c;
            background: #fdf2f2;
        }

        .source-item {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .source-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .source-snippet {
            font-size: 14px;
            color: #7f8c8d;
            margin: 5px 0;
        }

        .source-url {
            font-size: 12px;
            color: #3498db;
            text-decoration: none;
        }

        .source-url:hover {
            text-decoration: underline;
        }

        #graph-svg {
            width: 100%;
            height: 100%;
            background: #fafafa;
        }

        .node {
            cursor: pointer;
            stroke-width: 2.5;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .node.unlearned {
            fill: #95a5a6;
            stroke: #7f8c8d;
        }

        .node.lit {
            fill: #2ecc71;
            stroke: #27ae60;
        }

        .node.recommended {
            fill: #95a5a6;
            stroke: #f39c12;
            stroke-width: 4;
        }

        .node-label {
            font-size: 10px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
        }

        .label-container {
            pointer-events: none;
        }

        .node-label-line {
            font-size: 10px;
            font-weight: 600;
            text-anchor: middle;
            user-select: none;
            pointer-events: none;
        }

        .link {
            stroke: #bdc3c7;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(0,0,0,0.9);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 18px;
            color: #7f8c8d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .source-item.source-highlight {
            border-left: 6px solid #e67e22 !important;
            box-shadow: 0 0 10px #e67e22;
            background: #fffbe6;
            transition: box-shadow 0.2s, background 0.2s, border-color 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è Mini Roadmap Agent</h1>
            <p>Generate AI-powered learning roadmaps for any topic</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <input type="text" id="topicInput" placeholder="Enter a learning topic (e.g., 'Python basics', 'JLPT N1 grammar')" value="Python basics">
                <button id="generateBtn">Generate Roadmap</button>
            </div>
        </div>

        <div class="main-content">
            <div class="graph-container">
                <div id="graph-loading" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Generating your roadmap...</span>
                </div>
                <svg id="graph-svg"></svg>
            </div>

            <div class="sidebar">
                <div class="dashboard">
                    <h3>Progress Dashboard</h3>
                    <div class="progress" id="progress-percentage">0%</div>
                    <div id="progress-details">0 / 0 completed</div>
                </div>

                <div class="panel">
                    <h3>üìã Agent Logs</h3>
                    <div id="logs-container">
                        <p style="color: #7f8c8d; text-align: center;">Generate a roadmap to see agent steps...</p>
                    </div>
                </div>

                <div class="panel">
                    <h3>üîç Sources</h3>
                    <div id="sources-container">
                        <p style="color: #7f8c8d; text-align: center;">Sources will appear here...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class RoadmapAgent {
            constructor() {
                this.svg = d3.select("#graph-svg");
                this.width = 800;
                this.height = 600;
                this.nodes = [];
                this.links = [];
                this.simulation = null;
                this.tooltip = null;
                
                this.setupSVG();
                this.setupEventListeners();
                this.createTooltip();
            }

            // Êñ∞Â¢ûÔºöÈ´ò‰∫ÆSourceÂç°Áâá
            highlightSourceCard(url) {
                const cards = document.querySelectorAll('.source-item');
                cards.forEach(card => {
                    const link = card.querySelector('.source-url');
                    if (link && link.href === url) {
                        card.classList.add('source-highlight');
                    }
                });
            }

            // Êñ∞Â¢ûÔºöÊ∏ÖÈô§È´ò‰∫Æ
            clearSourceHighlight() {
                document.querySelectorAll('.source-item.source-highlight').forEach(card => {
                    card.classList.remove('source-highlight');
                });
            }

            setupSVG() {
                // Define arrow marker
                this.svg.append("defs").selectAll("marker")
                    .data(["arrowhead"])
                    .enter().append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 20)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "#bdc3c7");
            }

            setupEventListeners() {
                const generateBtn = document.getElementById('generateBtn');
                const topicInput = document.getElementById('topicInput');

                generateBtn.addEventListener('click', () => this.generateRoadmap());
                topicInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.generateRoadmap();
                    }
                });
            }

            createTooltip() {
                this.tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0);
            }

            async generateRoadmap() {
                const topic = document.getElementById('topicInput').value.trim();
                if (!topic) return;

                const generateBtn = document.getElementById('generateBtn');
                const loadingDiv = document.getElementById('graph-loading');

                // Show loading state
                generateBtn.disabled = true;
                generateBtn.textContent = 'Generating...';
                loadingDiv.style.display = 'flex';
                this.clearAll();

                try {
                    const response = await fetch(`/agent/roadmap?topic=${encodeURIComponent(topic)}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.detail || 'Failed to generate roadmap');
                    }

                    this.displayRoadmap(data);
                    this.displayLogs(data.logs);
                    this.displaySources(data.sources);

                } catch (error) {
                    console.error('Error:', error);
                    this.displayError(error.message);
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Roadmap';
                    loadingDiv.style.display = 'none';
                }
            }

            displayRoadmap(data) {
                this.nodes = data.nodes.map(node => ({
                    ...node,
                    x: Math.random() * this.width,
                    y: Math.random() * this.height,
                    status: Math.random() > 0.7 ? 'lit' : 'unlearned',
                    level: 0 // Will be calculated below
                }));

                this.links = data.edges.map(edge => ({
                    source: edge.source,
                    target: edge.target,
                    relation: edge.relation
                }));

                // Calculate hierarchical levels for better vertical layout
                this.assignNodeLevels();

                // Mark some nodes as recommended (prerequisites of lit nodes)
                this.markRecommendedNodes();

                this.renderGraph();
                this.updateDashboard();
            }

            assignNodeLevels() {
                // Topological sort to assign levels (prerequisite depth)
                const nodeMap = new Map(this.nodes.map(node => [node.id, node]));
                const inDegree = new Map(this.nodes.map(node => [node.id, 0]));
                
                // Count incoming edges (prerequisites)
                this.links.forEach(link => {
                    inDegree.set(link.target, (inDegree.get(link.target) || 0) + 1);
                });
                
                // Start with nodes that have no prerequisites
                const queue = this.nodes.filter(node => inDegree.get(node.id) === 0);
                queue.forEach(node => node.level = 0);
                
                // Process nodes level by level
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    // Find all nodes that this node points to
                    this.links.forEach(link => {
                        if (link.source === current.id) {
                            const targetNode = nodeMap.get(link.target);
                            const newInDegree = inDegree.get(link.target) - 1;
                            inDegree.set(link.target, newInDegree);
                            
                            // Set level to be at least current level + 1
                            targetNode.level = Math.max(targetNode.level || 0, current.level + 1);
                            
                            if (newInDegree === 0) {
                                queue.push(targetNode);
                            }
                        }
                    });
                }
            }

            createHierarchy() {
                // Group nodes by level for positioning
                const hierarchy = {};
                this.nodes.forEach(node => {
                    if (!hierarchy[node.level]) {
                        hierarchy[node.level] = [];
                    }
                    hierarchy[node.level].push(node.id);
                });
                return hierarchy;
            }

            markRecommendedNodes() {
                const litNodes = new Set(this.nodes.filter(n => n.status === 'lit').map(n => n.id));
                const unlearnedNodes = new Set(this.nodes.filter(n => n.status === 'unlearned').map(n => n.id));

                this.nodes.forEach(node => {
                    if (node.status === 'unlearned') {
                        // Check if any of its targets are lit
                        const hasLitTarget = this.links.some(link => 
                            link.source === node.id && litNodes.has(link.target)
                        );
                        
                        if (hasLitTarget) {
                            node.status = 'recommended';
                        }
                    }
                });
            }

            renderGraph() {
                // Clear previous graph
                this.svg.selectAll("*:not(defs)").remove();

                // Create zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                // Create container for zoomable content
                const g = this.svg.append("g");

                // Create hierarchical layout for better vertical structure
                const hierarchy = this.createHierarchy();

                // Create simulation with vertical bias
                this.simulation = d3.forceSimulation(this.nodes)
                    .force("link", d3.forceLink(this.links)
                        .id(d => d.id)
                        .distance(d => d.target.level > d.source.level ? 120 : 80)
                        .strength(0.4))
                    .force("charge", d3.forceManyBody().strength(-200))
                    .force("center", d3.forceCenter(this.width / 2, this.height / 2));

                // Create links (ÂøÖÈ°ªÂä†‰∏ä)
                const link = g.append("g")
                    .attr("stroke", "#aaa")
                    .selectAll("path")
                    .data(this.links)
                    .enter().append("path")
                    .attr("class", "link")
                    .attr("marker-end", "url(#arrowhead)");

                // Create nodes
                const node = g.append("g")
                    .selectAll("circle")
                    .data(this.nodes)
                    .enter().append("circle")
                    .attr("class", d => `node ${d.status}`)
                    .attr("r", 25)
                    .on("mouseover", (event, d) => {
                        this.showTooltip(event, d);
                        this.highlightSourceCard(d.source_url);
                    })
                    .on("mouseout", (event, d) => {
                        this.hideTooltip();
                        this.clearSourceHighlight();
                    })
                    .on("click", (event, d) => this.toggleNodeStatus(d))
                    .call(d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on("drag", (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on("end", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        }));

                // Create labels with automatic text wrapping using proper data binding
                const labelGroup = g.append("g").attr("class", "labels");

                // Smart text wrapping function
                const wrapText = (text, maxCharsPerLine = 18) => {
                    const words = text.split(/[\s\-()]+/);
                    const lines = [];
                    let currentLine = '';

                    words.forEach(word => {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        if (testLine.length <= maxCharsPerLine) {
                            currentLine = testLine;
                        } else {
                            if (currentLine) lines.push(currentLine);
                            currentLine = word;
                        }
                    });
                    if (currentLine) lines.push(currentLine);

                    // If we still have lines that are too long, break them
                    const finalLines = [];
                    lines.forEach(line => {
                        if (line.length <= maxCharsPerLine) {
                            finalLines.push(line);
                        } else {
                            // Break long words
                            for (let i = 0; i < line.length; i += maxCharsPerLine) {
                                finalLines.push(line.substring(i, i + maxCharsPerLine));
                            }
                        }
                    });

                    return finalLines.slice(0, 3); // Maximum 3 lines
                };

                // Add wrapped lines to each node data
                this.nodes.forEach(node => {
                    node.wrappedLines = wrapText(node.title);
                });

                const labelContainers = labelGroup.selectAll(".label-container")
                    .data(this.nodes)
                    .enter().append("g")
                    .attr("class", "label-container");

                // Add text lines for each node
                labelContainers.each(function(d) {
                    const container = d3.select(this);
                    d.wrappedLines.forEach((line, i) => {
                        container.append("text")
                            .attr("class", "node-label-line")
                            .attr("dy", `${i * 1.2}em`)
                            .style("font-size", "10px")
                            .style("font-weight", "600")
                            .style("text-anchor", "middle")
                            .style("fill", "#2c3e50")
                            .style("paint-order", "stroke")
                            .style("stroke", "white")
                            .style("stroke-width", "2px")
                            .style("stroke-linejoin", "round")
                            .style("dominant-baseline", "central")
                            .text(line);
                    });
                });

                // Update positions on simulation tick
                this.simulation.on("tick", () => {
                    link.attr("d", d => {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    // Position label containers below nodes
                    labelContainers
                        .attr("transform", d => `translate(${d.x}, ${d.y + 50})`);
                });

                // Initial zoom to fit content
                setTimeout(() => {
                    const bounds = g.node().getBBox();
                    const parent = this.svg.node().getBoundingClientRect();
                    const fullWidth = parent.width;
                    const fullHeight = parent.height;
                    const width = bounds.width;
                    const height = bounds.height;
                    const midX = bounds.x + width / 2;
                    const midY = bounds.y + height / 2;

                    const scale = Math.min(fullWidth / width, fullHeight / height) * 0.8;
                    const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

                    this.svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                }, 100);
            }

            showTooltip(event, d) {
                this.tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                
                this.tooltip.html(`
                    <strong>${d.title}</strong><br/>
                    <em>Type:</em> ${d.kind}<br/>
                    <em>Status:</em> ${d.status}<br/><br/>
                    ${d.brief}
                `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            }

            hideTooltip() {
                this.tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }

            toggleNodeStatus(node) {
                if (node.status === 'unlearned') {
                    node.status = 'lit';
                } else if (node.status === 'lit') {
                    node.status = 'unlearned';
                }
                
                // Update recommended nodes
                this.markRecommendedNodes();
                
                // Update visual appearance
                this.svg.selectAll(".node")
                    .attr("class", d => `node ${d.status}`);
                
                this.updateDashboard();
            }

            updateDashboard() {
                const litCount = this.nodes.filter(n => n.status === 'lit').length;
                const totalCount = this.nodes.length;
                const percentage = totalCount > 0 ? Math.round((litCount / totalCount) * 100) : 0;

                document.getElementById('progress-percentage').textContent = `${percentage}%`;
                document.getElementById('progress-details').textContent = `${litCount} / ${totalCount} completed`;
            }

            displayLogs(logs) {
                const container = document.getElementById('logs-container');
                container.innerHTML = '';

                logs.forEach(log => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${log.stage}`;
                    
                    const timestamp = new Date(log.ts).toLocaleTimeString();
                    logEntry.innerHTML = `
                        <strong>[${timestamp}] ${log.stage.toUpperCase()}:</strong><br/>
                        ${log.message}
                    `;
                    
                    container.appendChild(logEntry);
                });
            }

            displaySources(sources) {
                const container = document.getElementById('sources-container');
                container.innerHTML = '';

                sources.forEach(source => {
                    const sourceItem = document.createElement('div');
                    sourceItem.className = 'source-item';
                    sourceItem.innerHTML = `
                        <div class="source-title">${source.title}</div>
                        <div class="source-snippet">${source.snippet}</div>
                        <a href="${source.url}" class="source-url" target="_blank">${source.url}</a>
                    `;
                    container.appendChild(sourceItem);
                });
            }

            displayError(message) {
                const container = document.getElementById('logs-container');
                container.innerHTML = `
                    <div class="log-entry error">
                        <strong>ERROR:</strong><br/>
                        ${message}
                    </div>
                `;
            }

            clearAll() {
                document.getElementById('logs-container').innerHTML = '<p style="color: #7f8c8d; text-align: center;">Generating roadmap...</p>';
                document.getElementById('sources-container').innerHTML = '<p style="color: #7f8c8d; text-align: center;">Loading sources...</p>';
                document.getElementById('progress-percentage').textContent = '0%';
                document.getElementById('progress-details').textContent = '0 / 0 completed';
                this.svg.selectAll("*:not(defs)").remove();
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new RoadmapAgent();
        });
    </script>
</body>
</html>